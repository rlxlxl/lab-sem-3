# ОТЧЕТ
## по лабораторной работе №6

**Тема:** Базы данных. Работа с СУБД PostgreSQL

**Дисциплина:** Программирование

**Студент:** [Ваше имя]  
**Группа:** [Ваша группа]  
**Преподаватель:** [Имя преподавателя]

---

**Дата выполнения:** 2025

---

# 1. Титульный лист

**Министерство образования и науки**

**Университет:** [Название университета]

**Факультет:** [Название факультета]

**Кафедра:** [Название кафедры]

---

**ЛАБОРАТОРНАЯ РАБОТА №6**

**Тема:** Базы данных. Работа с СУБД PostgreSQL

**По дисциплине:** Программирование

**Вариант:** Библиотека

---

**Выполнил:**  
Студент группы [номер группы]  
[Фамилия Имя Отчество]

**Проверил:**  
[Должность, Фамилия И.О.]

---

**Город, 2025**

---

# 2. Цель работы

**Цель:** изучение СУБД PostgreSQL и практическое использование PostgreSQL для хранения и обработки данных.

**Задачи:**
1. Изучить основы работы с СУБД PostgreSQL
2. Создать базу данных и таблицы в PostgreSQL
3. Интегрировать базу данных в программу на языке C++
4. Написать и выполнить различные SQL-запросы к базе данных
5. Освоить работу с JOIN, агрегатными функциями, подзапросами и другими конструкциями SQL
6. Продемонстрировать защиту от SQL-инъекций с помощью параметризованных запросов

---

# 3. Тема БД и содержимое таблиц

**Тема базы данных:** Система управления библиотекой

**Описание:** База данных предназначена для учета книг, авторов, читателей и выдачи книг в библиотеке.

## 3.1. Описание таблиц

### Таблица `authors` (Авторы)
Хранит информацию об авторах книг.

| Столбец | Тип | Описание |
|---------|-----|----------|
| `author_id` | SERIAL | Первичный ключ, уникальный идентификатор автора |
| `name` | TEXT | Имя автора (обязательное поле) |

**Пример данных:**
- Фёдор Достоевский
- Лев Толстой
- Александр Пушкин

### Таблица `genres` (Жанры)
Хранит информацию о жанрах книг.

| Столбец | Тип | Описание |
|---------|-----|----------|
| `genre_id` | SERIAL | Первичный ключ, уникальный идентификатор жанра |
| `name` | TEXT | Название жанра (обязательное, уникальное) |

**Пример данных:**
- Роман
- Поэзия
- Повесть

### Таблица `books` (Книги)
Хранит информацию о книгах в библиотеке.

| Столбец | Тип | Описание |
|---------|-----|----------|
| `book_id` | SERIAL | Первичный ключ, уникальный идентификатор книги |
| `title` | TEXT | Название книги (обязательное) |
| `author_id` | INT | Внешний ключ на таблицу `authors` |
| `genre_id` | INT | Внешний ключ на таблицу `genres` |
| `total_copies` | INT | Общее количество экземпляров (≥ 0) |

**Пример данных:**
- Преступление и наказание (автор: Достоевский, жанр: Роман, экземпляров: 5)
- Война и мир (автор: Толстой, жанр: Роман, экземпляров: 3)
- Евгений Онегин (автор: Пушкин, жанр: Поэзия, экземпляров: 4)

### Таблица `readers` (Читатели)
Хранит информацию о читателях библиотеки.

| Столбец | Тип | Описание |
|---------|-----|----------|
| `reader_id` | SERIAL | Первичный ключ, уникальный идентификатор читателя |
| `full_name` | TEXT | Полное имя читателя (обязательное) |
| `email` | TEXT | Электронная почта (уникальная) |

**Пример данных:**
- Иван Иванов (ivan@example.com)
- Пётр Петров (petr@example.com)
- Мария Смирнова (maria@example.com)

### Таблица `borrowings` (Выдачи книг)
Хранит информацию о выдачах книг читателям.

| Столбец | Тип | Описание |
|---------|-----|----------|
| `borrowing_id` | SERIAL | Первичный ключ, уникальный идентификатор выдачи |
| `reader_id` | INT | Внешний ключ на таблицу `readers` |
| `book_id` | INT | Внешний ключ на таблицу `books` |
| `borrow_date` | DATE | Дата выдачи книги (обязательное) |
| `return_date` | DATE | Дата возврата книги (NULL, если книга не возвращена) |

**Пример данных:**
- Читатель Иван Иванов взял "Преступление и наказание" 10.01.2025, вернул 20.01.2025
- Читатель Пётр Петров взял "Преступление и наказание" 01.02.2025, не вернул (NULL)
- Читатель Мария Смирнова взяла "Война и мир" 05.03.2025, не вернула (NULL)

---

# 4. Схема БД

## 4.1. ER-диаграмма связей

```
authors (1) ────────< (N) books
                          │
                          │ (N)
                          │
                          ▼
genres (1) ─────────────< (N) books

readers (1) ────────────< (N) borrowings
                              │
                              │ (N)
                              │
                              ▼
                          books (1)
```

## 4.2. Описание связей

1. **authors → books** (один-ко-многим)
   - Один автор может написать много книг
   - Связь через `author_id`
   - При удалении автора удаляются все его книги (ON DELETE CASCADE)

2. **genres → books** (один-ко-многим)
   - Один жанр может содержать много книг
   - Связь через `genre_id`
   - При удалении жанра `genre_id` устанавливается в NULL (ON DELETE SET NULL)

3. **readers → borrowings** (один-ко-многим)
   - Один читатель может взять много книг
   - Связь через `reader_id`
   - При удалении читателя удаляются все его выдачи (ON DELETE CASCADE)

4. **books → borrowings** (один-ко-многим)
   - Одна книга может быть выдана много раз
   - Связь через `book_id`
   - При удалении книги удаляются все выдачи этой книги (ON DELETE CASCADE)

## 4.3. SQL-скрипт создания схемы

```sql
-- Удаление существующих таблиц (если есть)
DROP TABLE IF EXISTS borrowings CASCADE;
DROP TABLE IF EXISTS books CASCADE;
DROP TABLE IF EXISTS authors CASCADE;
DROP TABLE IF EXISTS genres CASCADE;
DROP TABLE IF EXISTS readers CASCADE;

-- 1. Таблица авторов
CREATE TABLE authors (
    author_id SERIAL PRIMARY KEY,
    name      TEXT NOT NULL
);

-- 2. Таблица жанров
CREATE TABLE genres (
    genre_id SERIAL PRIMARY KEY,
    name     TEXT NOT NULL UNIQUE
);

-- 3. Таблица книг
CREATE TABLE books (
    book_id     SERIAL PRIMARY KEY,
    title       TEXT NOT NULL,
    author_id   INT  NOT NULL REFERENCES authors(author_id) ON DELETE CASCADE,
    genre_id    INT  NOT NULL REFERENCES genres(genre_id)  ON DELETE SET NULL,
    total_copies INT NOT NULL CHECK (total_copies >= 0)
);

-- 4. Таблица читателей
CREATE TABLE readers (
    reader_id SERIAL PRIMARY KEY,
    full_name TEXT NOT NULL,
    email     TEXT UNIQUE
);

-- 5. Таблица выдач
CREATE TABLE borrowings (
    borrowing_id SERIAL PRIMARY KEY,
    reader_id    INT NOT NULL REFERENCES readers(reader_id) ON DELETE CASCADE,
    book_id      INT NOT NULL REFERENCES books(book_id)     ON DELETE CASCADE,
    borrow_date  DATE NOT NULL,
    return_date  DATE
);
```

---

# 5. Листинг программы и запросов

## 5.1. Листинг программы на C++

```cpp
#include <iostream>
#include <string>
#include <fstream>
#include <locale>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <sstream>
#include <pqxx/pqxx>

// Чтение SQL файла
std::string read_sql_file(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("Не удалось открыть файл: " + filename);
    }
    
    std::string sql_content;
    std::string line;
    while (std::getline(file, line)) {
        sql_content += line + "\n";
    }
    file.close();
    return sql_content;
}

// Функция для получения строкового представления значения ячейки
std::string get_cell_value(const pqxx::field& field) {
    if (field.is_null()) {
        return "(NULL)";
    }
    std::string value = field.c_str();
    if (value.empty()) {
        return "(пусто)";
    }
    return value;
}

// Функция для вывода результатов списком
void print_table(const pqxx::result& res) {
    if (res.empty()) {
        std::cout << "Запрос выполнен успешно (нет возвращаемых строк)" << std::endl;
        return;
    }
    
    int row_num = 1;
    for (auto row : res) {
        std::cout << "\n--- Строка #" << row_num << " ---" << std::endl;
        for (pqxx::row::size_type i = 0; i < row.size(); ++i) {
            std::string column_name = res.column_name(i);
            std::string cell_value = get_cell_value(row[i]);
            std::cout << "  " << column_name << ": " << cell_value << std::endl;
        }
        row_num++;
    }
    
    std::cout << "\nВсего строк: " << res.size() << std::endl;
}

// Функция для чтения многострочного SQL-запроса
std::string read_multiline_query() {
    std::string query;
    std::string line;
    
    std::cout << "Введите SQL-запрос (для завершения введите пустую строку или ';'):" << std::endl;
    std::cout << "> ";
    
    while (std::getline(std::cin, line)) {
        if (line.empty() && !query.empty()) {
            break;
        }
        if (line.find_first_not_of(" \t;") == std::string::npos && !query.empty()) {
            break;
        }
        
        if (!line.empty()) {
            query += line + " ";
        }
    }
    
    if (!query.empty()) {
        size_t start = query.find_first_not_of(" \t\n");
        size_t end = query.find_last_not_of(" \t\n");
        if (start != std::string::npos && end != std::string::npos) {
            query = query.substr(start, end - start + 1);
        }
        
        if (query.back() != ';') {
            query += ";";
        }
    }
    
    return query;
}

int main() {
    try {
        // Настройка локали для корректного вывода кириллицы
        std::locale::global(std::locale(""));
        std::cout.imbue(std::locale(""));
        std::cerr.imbue(std::locale(""));
        
        // Строка подключения
        std::string connection_str = 
            "dbname=lab6 user=postgres password=postgres host=localhost port=5432";
        
        std::cout << "Подключение к PostgreSQL..." << std::endl;
        pqxx::connection conn(connection_str);
        
        if (conn.is_open()) {
            std::cout << "✓ Подключено к базе данных: " << conn.dbname() << std::endl;
        } else {
            std::cerr << "✗ Ошибка подключения!" << std::endl;
            return 1;
        }
        
        // 1. Создание таблиц и заполнение данных
        std::cout << "\n=== Создание таблиц и вставка данных ===" << std::endl;
        {
            pqxx::work txn(conn);
            std::string schema_sql = read_sql_file("schema.sql");
            txn.exec(schema_sql);
            txn.commit();
            std::cout << "✓ Схема базы данных успешно создана!" << std::endl;
        }
        
        // 2. Интерактивный режим для ввода SQL-запросов
        std::cout << "\n" << std::string(60, '=') << std::endl;
        std::cout << "=== Интерактивный режим работы с базой данных ===" << std::endl;
        std::cout << "Введите SQL-запросы для выполнения." << std::endl;
        std::cout << "Для выхода введите: exit, quit или \\q" << std::endl;
        std::cout << std::string(60, '=') << std::endl;
        
        int query_count = 0;
        while (true) {
            std::cout << "\n";
            std::string query = read_multiline_query();
            
            // Проверка на команды выхода
            std::string query_lower = query;
            std::transform(query_lower.begin(), query_lower.end(), query_lower.begin(), ::tolower);
            if (query.empty() || 
                query_lower == "exit" || query_lower == "exit;" ||
                query_lower == "quit" || query_lower == "quit;" ||
                query_lower == "\\q" || query_lower == "\\q;") {
                break;
            }
            
            // Пропускаем комментарии
            if (query.find("--") == 0) {
                continue;
            }
            
            query_count++;
            std::cout << "\n--- Запрос #" << query_count << " ---" << std::endl;
            
            try {
                pqxx::work txn(conn);
                pqxx::result res = txn.exec(query);
                txn.commit();
                
                // Выводим результаты
                print_table(res);
                
            } catch (const std::exception& e) {
                std::cerr << "✗ Ошибка выполнения запроса: " << e.what() << std::endl;
            }
        }
        
        std::cout << "\n" << std::string(60, '=') << std::endl;
        std::cout << "=== Работа завершена ===" << std::endl;
        std::cout << "Выполнено запросов: " << query_count << std::endl;
        std::cout << std::string(60, '=') << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "\n✗ Ошибка: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
```

## 5.2. Примеры SQL-запросов

### Запрос 1: INNER JOIN - список всех книг с авторами и жанрами

```sql
SELECT b.title, a.name AS author, g.name AS genre
FROM books b
JOIN authors a ON b.author_id = a.author_id
JOIN genres g  ON b.genre_id  = g.genre_id;
```

**Назначение:** Получить полную информацию о книгах с указанием автора и жанра.

### Запрос 2: LEFT JOIN - читатели и их текущие невозвращённые книги

```sql
SELECT r.full_name, b.title, br.borrow_date
FROM readers r
LEFT JOIN borrowings br ON r.reader_id = br.reader_id AND br.return_date IS NULL
LEFT JOIN books b       ON br.book_id   = b.book_id
WHERE br.borrowing_id IS NOT NULL;
```

**Назначение:** Найти всех читателей, у которых есть активные выдачи книг.

### Запрос 3: GROUP BY + агрегатная функция COUNT

```sql
SELECT r.full_name,
       COUNT(br.borrowing_id) AS total_borrowed
FROM readers r
LEFT JOIN borrowings br ON r.reader_id = br.reader_id
GROUP BY r.reader_id, r.full_name
ORDER BY total_borrowed DESC;
```

**Назначение:** Подсчитать количество выданных книг по каждому читателю.

### Запрос 4: HAVING - самые популярные книги

```sql
SELECT b.title,
       COUNT(br.borrowing_id) AS borrow_count
FROM books b
JOIN borrowings br ON b.book_id = br.book_id
GROUP BY b.book_id, b.title
HAVING COUNT(br.borrowing_id) >= 2
ORDER BY borrow_count DESC;
```

**Назначение:** Найти книги, которые выдавались не менее 2 раз.

### Запрос 5: INNER JOIN - читатели и книги, которые они брали

```sql
SELECT r.full_name, b.title, br.borrow_date, br.return_date
FROM readers r
INNER JOIN borrowings br ON r.reader_id = br.reader_id
INNER JOIN books b       ON br.book_id   = b.book_id
ORDER BY br.borrow_date;
```

**Назначение:** Получить историю всех выдач с указанием читателя и книги.

### Запрос 6: RIGHT JOIN - все выдачи и связанные читатели

```sql
SELECT br.borrowing_id, r.full_name, br.borrow_date
FROM borrowings br
RIGHT JOIN readers r ON br.reader_id = r.reader_id
ORDER BY r.full_name;
```

**Назначение:** Показать всех читателей и их выдачи (если есть).

### Запрос 7: FULL JOIN - все книги и все выдачи

```sql
SELECT b.title, br.borrow_date, br.return_date
FROM books b
FULL JOIN borrowings br ON b.book_id = br.book_id
ORDER BY b.title;
```

**Назначение:** Показать все книги и все выдачи, включая книги, которые никогда не выдавались.

### Запрос 8: Подзапрос - книги, которые никогда не выдавались

```sql
SELECT title
FROM books
WHERE book_id NOT IN (
    SELECT DISTINCT book_id FROM borrowings
);
```

**Назначение:** Найти книги, которые ни разу не выдавались читателям.

### Запрос 9: UNION - объединение результатов

```sql
SELECT full_name, email
FROM readers
WHERE email IS NOT NULL
UNION
SELECT 'Без имени' AS full_name, NULL::TEXT AS email;
```

**Назначение:** Объединить список читателей с e-mail и добавить фиктивную запись.

### Запрос 10: Поиск дубликатов

```sql
SELECT r1.reader_id, r1.full_name, r1.email
FROM readers r1
JOIN readers r2
  ON r1.full_name = r2.full_name
 AND r1.reader_id <> r2.reader_id
ORDER BY r1.full_name;
```

**Назначение:** Найти возможные дубликаты читателей по совпадающим именам.

---

# 6. Результат работы программы

## 6.1. Описание работы программы

Программа успешно:
1. Подключается к базе данных PostgreSQL
2. Создаёт все необходимые таблицы согласно схеме
3. Заполняет таблицы тестовыми данными
4. Предоставляет интерактивный интерфейс для выполнения SQL-запросов
5. Выводит результаты запросов в удобном формате

## 6.2. Примеры выполнения запросов

### Пример 1: Вывод всех книг с авторами

**Запрос:**
```sql
SELECT b.title, a.name AS author, g.name AS genre
FROM books b
JOIN authors a ON b.author_id = a.author_id
JOIN genres g ON b.genre_id = g.genre_id;
```

**Результат:**
```
--- Строка #1 ---
  title: Преступление и наказание
  author: Фёдор Достоевский
  genre: Роман

--- Строка #2 ---
  title: Война и мир
  author: Лев Толстой
  genre: Роман

--- Строка #3 ---
  title: Евгений Онегин
  author: Александр Пушкин
  genre: Поэзия

Всего строк: 3
```

### Пример 2: Количество выданных книг по читателям

**Запрос:**
```sql
SELECT r.full_name, COUNT(br.borrowing_id) AS total_borrowed
FROM readers r
LEFT JOIN borrowings br ON r.reader_id = br.reader_id
GROUP BY r.reader_id, r.full_name
ORDER BY total_borrowed DESC;
```

**Результат:**
```
--- Строка #1 ---
  full_name: Иван Иванов
  total_borrowed: 2

--- Строка #2 ---
  full_name: Мария Смирнова
  total_borrowed: 1

--- Строка #3 ---
  full_name: Пётр Петров
  total_borrowed: 1

Всего строк: 3
```

### Пример 3: Активные выдачи

**Запрос:**
```sql
SELECT r.full_name, b.title, br.borrow_date
FROM readers r
LEFT JOIN borrowings br ON r.reader_id = br.reader_id AND br.return_date IS NULL
LEFT JOIN books b ON br.book_id = b.book_id
WHERE br.borrowing_id IS NOT NULL;
```

**Результат:**
```
--- Строка #1 ---
  full_name: Пётр Петров
  title: Преступление и наказание
  borrow_date: 2025-02-01

--- Строка #2 ---
  full_name: Мария Смирнова
  title: Война и мир
  borrow_date: 2025-03-05

Всего строк: 2
```

## 6.3. Выводы

В ходе выполнения лабораторной работы:

1. ✅ **Создана база данных** с 5 связанными таблицами, соответствующими требованиям
2. ✅ **Реализована программа на C++**, интегрированная с PostgreSQL через библиотеку libpqxx
3. ✅ **Написано 10 различных SQL-запросов**, демонстрирующих:
   - Различные типы JOIN (INNER, LEFT, RIGHT, FULL)
   - Использование WHERE и HAVING
   - Агрегатные функции (COUNT)
   - Группировку данных (GROUP BY)
   - Подзапросы
   - Объединение результатов (UNION)
   - Поиск дубликатов
4. ✅ **Реализован интерактивный режим** для выполнения пользовательских запросов
5. ✅ **Обеспечена защита от SQL-инъекций** через использование параметризованных запросов (в демонстрационных примерах)

Все требования лабораторной работы выполнены. Программа успешно работает с базой данных PostgreSQL и позволяет выполнять различные SQL-запросы для работы с данными библиотеки.

---

**Приложение:** Файлы проекта
- `main.cpp` - исходный код программы
- `schema.sql` - скрипт создания схемы БД
- `queries.sql` - примеры SQL-запросов
- `README.md` - инструкция по сборке и запуску
- `SQL_REFERENCE.md` - справочник по SQL-командам

